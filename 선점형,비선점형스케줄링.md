
프로세스        도착시간         실행시간
A              0               30
B              5               10
C              10              15
D              15              10

FCFS, SJFM HRN, SRT, RR의 경우 반환시간 설명 

요청하신 프로세스 스케줄링 알고리즘별 반환 시간과 선점형 스케줄링의 우선순위는 다음과 같습니다.

(※ 프로세스 A가 세 번 기재되어, 순서대로 프로세스 A, B, C, D로 간주하고 계산하였습니다.)

프로세스

도착 시간 (Arrival)

실행 시간 (Burst)

A

0초

30초

B

5초

10초

C

10초

15초

D

15초

10초

📊 스케줄링별 반환 시간 요약
스케줄링 알고리즘

A 반환시간

B 반환시간

C 반환시간

D 반환시간

평균 반환시간

FCFS

30

35

45

50

40.0초

SJF (비선점)

30

35

55

35

38.75초

HRN (비선점)

30

35

55

35

38.75초

SRT (선점)

65

10

30

10

28.75초

RR (TQ=5)

65

20

45

30

40.0초

## 1. FCFS (First-Come, First-Served)
가장 먼저 도착한 프로세스를 순서대로 처리하는 비선점형 방식입니다.

실행 순서: A → B → C → D

계산 과정:

A 완료: 30초 | 반환 시간: 30 - 0 = 30초

B 완료: 30 + 10 = 40초 | 반환 시간: 40 - 5 = 35초

C 완료: 40 + 15 = 55초 | 반환 시간: 55 - 10 = 45초

D 완료: 55 + 10 = 65초 | 반환 시간: 65 - 15 = 50초

평균 반환시간: (30 + 35 + 45 + 50) / 4 = 40초

## 2. SJF (Shortest Job First, 비선점)
준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 것을 먼저 처리하는 비선점형 방식입니다.

실행 순서: A → B → D → C

계산 과정:

0초: A만 도착, A 실행

30초: A 완료. 준비 큐에 B(10), C(15), D(10) 도착.

실행 시간이 가장 짧은 B와 D 중, 먼저 도착한 B가 실행 (FCFS 타이 브레이커 적용)

40초: B 완료. 준비 큐에 C(15), D(10) 존재.

실행 시간이 더 짧은 D 실행

50초: D 완료. 남은 C 실행

65초: C 완료.

반환 시간:

A: 30 - 0 = 30초

B: 40 - 5 = 35초

D: 50 - 15 = 35초

C: 65 - 10 = 55초

평균 반환시간: (30 + 35 + 55 + 35) / 4 = 38.75초

## 3. HRN (Highest Response Ratio Next)
대기 시간과 실행 시간을 모두 고려하여 우선순위를 정하는 비선점형 방식입니다.
(우선순위 = (대기 시간 + 실행 시간) / 실행 시간)

실행 순서: A → B → D → C

계산 과정:

0초: A만 도착, A 실행

30초: A 완료. B, C, D의 우선순위 계산.

B: (대기 25 + 실행 10) / 10 = 3.5 (최고 우선순위)

C: (대기 20 + 실행 15) / 15 = 2.33

D: (대기 15 + 실행 10) / 10 = 2.5

40초: B 완료. C, D의 우선순위 재계산.

C: (대기 30 + 실행 15) / 15 = 3.0

D: (대기 25 + 실행 10) / 10 = 3.5 (최고 우선순위)

50초: D 완료. 남은 C 실행.

반환 시간:

A: 30 - 0 = 30초

B: 40 - 5 = 35초

D: 50 - 15 = 35초

C: 65 - 10 = 55초

평균 반환시간: (30 + 35 + 55 + 35) / 4 = 38.75초

## 4. SRT (Shortest Remaining Time)
SJF의 선점형 방식으로, 새로 도착한 프로세스의 실행 시간이 현재 실행 중인 프로세스의 남은 시간보다 짧으면 CPU를 빼앗습니다.

우선순위 및 실행 흐름:

0초: A 실행 (남은 시간 30)

5초: B 도착 (실행 10). A의 남은 시간(25)보다 짧으므로 B가 선점 (우선순위: B > A). B 실행.

15초: B 완료. 준비 큐에는 A(남은 시간 25), C(15), D(10) 존재. 남은 시간이 가장 짧은 D가 실행 (우선순위: D > C > A).

25초: D 완료. 준비 큐에는 A(25), C(15). 남은 시간이 더 짧은 C가 실행 (우선순위: C > A).

40초: C 완료. 남은 A 실행.

65초: A 최종 완료.

반환 시간:

B 완료: 15초 | 반환 시간: 15 - 5 = 10초

D 완료: 25초 | 반환 시간: 25 - 15 = 10초

C 완료: 40초 | 반환 시간: 40 - 10 = 30초

A 완료: 65초 | 반환 시간: 65 - 0 = 65초

평균 반환시간: (65 + 10 + 30 + 10) / 4 = 28.75초

## 5. RR (Round Robin, Time Quantum = 5)
모든 프로세스가 CPU를 **시간 할당량(Time Quantum, TQ)**만큼 번갈아 사용하는 선점형 방식입니다. (TQ=5로 가정)

우선순위 및 실행 흐름: 우선순위는 준비 큐의 순서에 따라 결정됩니다.

0-5: A 실행 (A 남은 시간: 25)

5-10: B 실행 (B 남은 시간: 5). A는 큐의 뒤로 이동. [B, A]

10-15: A 실행 (A 남은 시간: 20). B, C가 큐에 있음. [A, C, B]

15-20: C 실행 (C 남은 시간: 10). A, B, D가 큐에 있음. [C, B, D, A]

20-25: B 실행 (B 남은 시간: 0). B 완료.

25-30: D 실행 (D 남은 시간: 5)

30-35: A 실행 (A 남은 시간: 15)

35-40: C 실행 (C 남은 시간: 5)

40-45: D 실행 (D 남은 시간: 0). D 완료.

45-50: A 실행 (A 남은 시간: 10)

50-55: C 실행 (C 남은 시간: 0). C 완료.

55-65: A 실행 (남은 10초 모두 실행). A 완료.

반환 시간:

B 완료: 25초 | 반환 시간: 25 - 5 = 20초

D 완료: 45초 | 반환 시간: 45 - 15 = 30초

C 완료: 55초 | 반환 시간: 55 - 10 = 45초

A 완료: 65초 | 반환 시간: 65 - 0 = 65초

평균 반환시간: (65 + 20 + 45 + 30) / 4 = 40초


<h1>SRT, RR 부연 설명 </h1>
<h2>SRT</h2>
## 🚀 SRT (Shortest Remaining Time) 스케줄링
SRT는 '가장 급한 일 먼저 처리하기' 전략입니다. 새로운 작업이 도착했을 때, 지금 하고 있는 일의 남은 시간보다 새로 온 일이 더 빨리 끝날 것 같으면 하던 일을 멈추고 새 일을 먼저 처리합니다.


(0~5초): A가 실행됩니다.

(5초): B(실행 10)가 도착. 현재 실행 중인 A의 남은 시간(25)보다 B가 훨씬 짧으므로, A를 멈추고 B가 CPU를 차지(선점)합니다.

(15초): B가 끝나고, D(실행 10)가 도착. 준비된 프로세스는 A(남은 시간 25)와 C(15), D(10)입니다. 이 중 남은 실행 시간이 가장 짧은 D가 실행됩니다.

(25초): D가 끝나고, A(25)와 C(15) 중 더 짧은 C가 실행됩니다.

(40초): C가 끝나고, 마지막으로 남은 A의 나머지 부분이 실행됩니다.

🏥 응급실 비유
SRT는 응급실의 의사와 같습니다.
의사가 가벼운 찰과상 환자(긴 작업 A)를 치료하고 있는데, 심장마비 환자(짧고 긴급한 작업 B)가 실려옵니다. 의사는 즉시 찰과상 치료를 멈추고 심장마비 환자를 먼저 살립니다. 이처럼 더 긴급하고 빨리 끝낼 수 있는 환자(프로세스)가 나타나면 기존 환자의 치료를 잠시 멈추는 방식이 바로 SRT


<h2>RR</h2>
물론입니다. 선점형 스케줄링인 SRT와 RR에 대해 간트 차트(Gantt Chart) 그림과 실생활 예시를 통해 더 쉽게 설명해 드릴게요.

(프로세스 정보는 이전과 동일합니다: A(도착 0, 실행 30), B(도착 5, 실행 10), C(도착 10, 실행 15), D(도착 15, 실행 10))

## 🚀 SRT (Shortest Remaining Time) 스케줄링
SRT는 '가장 급한 일 먼저 처리하기' 전략입니다. 새로운 작업이 도착했을 때, 지금 하고 있는 일의 남은 시간보다 새로 온 일이 더 빨리 끝날 것 같으면 하던 일을 멈추고 새 일을 먼저 처리합니다.

<h3>흐름</h3>

(0~5초): A가 실행됩니다.

(5초): B(실행 10)가 도착. 현재 실행 중인 A의 남은 시간(25)보다 B가 훨씬 짧으므로, A를 멈추고 B가 CPU를 차지(선점)합니다.

(15초): B가 끝나고, D(실행 10)가 도착. 준비된 프로세스는 A(남은 시간 25)와 C(15), D(10)입니다. 이 중 남은 실행 시간이 가장 짧은 D가 실행됩니다.

(25초): D가 끝나고, A(25)와 C(15) 중 더 짧은 C가 실행됩니다.

(40초): C가 끝나고, 마지막으로 남은 A의 나머지 부분이 실행됩니다.

🏥 응급실 비유
SRT는 응급실의 의사와 같습니다.
의사가 가벼운 찰과상 환자(긴 작업 A)를 치료하고 있는데, 심장마비 환자(짧고 긴급한 작업 B)가 실려옵니다. 의사는 즉시 찰과상 치료를 멈추고 심장마비 환자를 먼저 살립니다. 이처럼 더 긴급하고 빨리 끝낼 수 있는 환자(프로세스)가 나타나면 기존 환자의 치료를 잠시 멈추는 방식이 바로 SRT입니다.

## 🎡 RR (Round Robin) 스케줄링
RR은 '모두에게 공평하게 기회 주기' 전략입니다. 각 프로세스에게 아주 짧은 시간(Time Quantum)만 CPU를 사용하게 하고, 시간이 다 되면 무조건 다음 프로세스에게 차례를 넘깁니다.

<h3>흐름</h3>

프로세스들은 정해진 시간(5초)만큼 실행된 후, 아직 작업이 남았다면 대기열(Ready Queue)의 맨 뒤로 가서 자기 차례를 다시 기다립니다.

A는 총 65초가 걸려 끝났지만, 그동안 B, C, D도 중간중간 CPU를 사용하며 작업을 진행할 수 있었습니다. 이 덕분에 짧은 작업들이 너무 오래 기다리지 않고 비교적 빨리 응답을 받을 수 있습니다.

🏀 놀이공원 인기 기구 비유
RR은 놀이공원의 인기 있는 놀이기구를 타는 것과 같습니다.
한 번에 5분(Time Quantum)만 탈 수 있고, 시간이 되면 무조건 내려야 합니다. 만약 더 타고 싶으면 다시 줄의 맨 뒤로 가서 차례를 기다려야 하죠. 이 방식은 한 사람이 놀이기구를 독차지하는 것을 막고, 모든 사람이 공평하게 기회를 얻도록 합니다. 어떤 작업이 끝나든 말든 정해진 시간이 되면 교체하는 점이 RR의 핵심입니다.
